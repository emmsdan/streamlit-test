# -*- coding: utf-8 -*-
"""App_v5.5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1E0X9U1nI-2YPh5tNkrh-K8g3lFZhDf9L
"""

import streamlit as st
import pandas as pd
from PIL import Image
import re
from difflib import SequenceMatcher
import os
import csv
from datetime import datetime


LOG_PATH = "failure_log.csv"

GENERIC_TOKENS = {"pain", "ache", "aches", "soreness", "discomfort"}
GENERIC_SYNONYMS = {"pain", "ache", "aches", "soreness", "discomfort", "tenderness"}

def log_failure(record: dict):
    file_exists = os.path.isfile(LOG_PATH)
    with open(LOG_PATH, "a", newline="", encoding="utf-8") as f:
        writer = csv.DictWriter(f, fieldnames=list(record.keys()))
        if not file_exists:
            writer.writeheader()
        writer.writerow(record)

def analytics_page():
    st.header("📊 App Failure Report")
    if not os.path.isfile(LOG_PATH):
        st.info("No failures logged yet.")
        return

    df = pd.read_csv(LOG_PATH, parse_dates=["timestamp"])
    st.subheader("Recent Failures")
    st.dataframe(df.sort_values("timestamp", ascending=False).head(20))

    st.subheader("Failures by Reason")
    counts = df["reason"].value_counts().reset_index()
    counts.columns = ["Reason","Count"]
    st.table(counts)

def stem(word: str) -> str:
    w = word.lower().strip()
    for suf in ("ing", "ion", "ed", "s", "ness", "able"):
        if w.endswith(suf):
            return w[: -len(suf)]
    return w

st.set_page_config(page_title="LEXY... LexMedical AI Triage System", page_icon="🩺", layout="centered")

# --- Mobile-friendly, high-contrast styles ---
st.markdown("""
<style>
.report-block {
  background-color: #f8d7da;
  border: 1px solid #f5c6cb;
  border-radius: 10px;
  padding: 16px;
  font-size: 1rem;
  line-height: 1.6;
  color: #2b0000;
  word-wrap: break-word;
  overflow-wrap: anywhere;
}
.report-block--ok {
  background-color: #d4edda;
  border-color: #c3e6cb;
  color: #062b0a;
}            
.report-block--warn {
  background-color: #fff3cd;
  border: 1px solid #ffeeba;
  color: #3a2e00;
}
.emergency-block {
  margin-top: 16px;
  padding: 14px;
  background-color: #f8d7da;
  border: 1px solid #f5c6cb;
  border-radius: 10px;
  font-weight: 600;
  font-size: 1rem;
  line-height: 1.6;
  color: #2b0000;
  word-wrap: break-word;
  overflow-wrap: anywhere;
}
@media (max-width: 640px) {
  .report-block, .emergency-block {
    font-size: 1.05rem;
    line-height: 1.7;
    padding: 18px;
  }
  .stButton > button { width: 100% !important; }
}
</style>
""", unsafe_allow_html=True)

# Initialize session state safely
if 'free_input_mode' not in st.session_state:
    st.session_state.free_input_mode = False
if 'page' not in st.session_state:
    st.session_state.page = "welcome"
if 'user_data' not in st.session_state:
    st.session_state.user_data = {}
if 'current_condition' not in st.session_state:
    st.session_state.current_condition = None
if 'confirmed_risks' not in st.session_state:
    st.session_state.confirmed_risks = []
if 'matched_conditions' not in st.session_state:
    st.session_state.matched_conditions = pd.DataFrame()
if 'logged_in' not in st.session_state:
    st.session_state.logged_in = False

@st.cache_data
def load_data():
    df = pd.read_excel("SymptomBotDB.xlsx")
    # ── Normalize every header: remove leading/trailing whitespace ──
    df.columns = df.columns.str.strip()
    return df
# --- Free-text normalization driven by Excel (FreeTextMap sheet) ---

@st.cache_data
def load_freetext_map() -> dict:
    """
    Reads SymptomBotDB.xlsx -> sheet 'FreeTextMap' with columns:
      from_phrase, to_phrase  (case-insensitive)
    Returns dict {from_phrase_lower: to_phrase_lower}.
    If the sheet is missing, returns {} (no-op).
    """
    try:
        df_map = pd.read_excel("SymptomBotDB.xlsx", sheet_name="FreeTextMap")
        df_map.columns = df_map.columns.str.strip().str.lower()
        if not {"from_phrase","to_phrase"}.issubset(df_map.columns):
            return {}
        # build lowercase map, drop blanks
        m = {}
        for _, r in df_map.iterrows():
            fp = str(r["from_phrase"]).strip().lower()
            tp = str(r["to_phrase"]).strip().lower()
            if fp and tp and fp != "nan" and tp != "nan":
                m[fp] = tp
        return m
    except Exception:
        return {}

FT_MAP = load_freetext_map()

# c) fuzzy-stem match across token pairs (safer)
def ok_pair(us, ds):
    # ignore very short tokens for fuzzy; exact/substring already handled earlier
    if len(us) < 4 or len(ds) < 4:
        return False
    # require same starting letter OR substring relation to avoid heart≈ear/hurt
    if not (us[0] == ds[0] or us in ds or ds in us):
        return False
    return SequenceMatcher(None, us, ds).ratio() >= 0.80  # was 0.65


def normalize_free_text(raw: str) -> str:
    """
    Minimal, safe normalization:
      - lowercase + trim
      - unify curly quotes
      - apply FreeTextMap replacements (longest-first)
      - a couple high-impact typo/alias fixes
    Returns a SINGLE normalized string you feed into your existing matcher.
    """
    if not raw:
        return ""
    text = raw.strip().lower()

    # normalize curly quotes to ascii to avoid miss matches
    text = (text
            .replace("’", "'")
            .replace("‘", "'")
            .replace("“", '"')
            .replace("”", '"'))

    # tiny typo fix that bites often
    text = text.replace("heatbeat", "heartbeat")

    # Apply Excel-driven phrase replacements, longest keys first to avoid partial shadowing
    if FT_MAP:
        for k in sorted(FT_MAP.keys(), key=len, reverse=True):
            if k in text:
                text = text.replace(k, FT_MAP[k])

    return text


def load_logo():
    return Image.open("logo.png")

db = load_data()
logo = load_logo()

# --- UTILITY FUNCTIONS ---


def is_gender_allowed(primary_category, gender, suppress_error=False):
    primary_category = primary_category.replace("’", "'")
    WOMEN_SPECIFIC = {
        "Women's Health", "Pelvic Inflammatory Disease", "Breast Lump",
        "Cervical Cancer", "Menopause", "Fibroids", "Heavy Menstrual Bleeding",
        "Yeast Infection", "Bacterial Vaginosis", "Endometriosis", "PCOS",
        "Pelvic Organ Prolapse", "Ovarian Cyst", "Ectopic Pregnancy"
    }
    MEN_SPECIFIC = {
        "Men's Health", "Prostatitis", "Testicular Torsion",
        "Benign Prostatic Hyperplasia", "Varicocele", "Balanitis"
    }
    if gender == "Male" and primary_category in WOMEN_SPECIFIC:
        if not suppress_error:
            st.error("This category is not available for your selected gender")
        return False
    if gender == "Female" and primary_category in MEN_SPECIFIC:
        if not suppress_error:
            st.error("This category is not available for your selected gender")
        return False
    return True

def display_grid(items, cols=3):
    rows = [items[i:i + cols] for i in range(0, len(items), cols)]
    for row in rows:
        columns = st.columns(len(row))
        for col, item in zip(columns, row):
            with col:
                if st.button(item, use_container_width=True):
                    return item
    return None

def generate_report():
    condition = st.session_state.current_condition
    user = st.session_state.user_data
    report = f"""
LEXAI SYMPTOM CHECKER REPORT
============================

Patient Details:
- Age: {user.get('age', 'N/A')}
- Gender: {user.get('gender', 'N/A')}

Assessment:
- Likely Condition: {condition['Condition'] if condition is not None else 'N/A'}
- Risk Factors: {', '.join(st.session_state.confirmed_risks) if st.session_state.confirmed_risks else 'None'}

Recommendation:
{condition['Escalated Recommendation' if st.session_state.get('is_high_risk') else 'Default Recommendation'] if condition is not None else ''}
"""
    return report

def similarity(a, b):
    return SequenceMatcher(None, a, b).ratio()

def match_conditions_by_symptoms(input_text, db):
    input_symptoms = [sym.strip().lower() for sym in input_text.split(",") if sym.strip()]
    matched_conditions = []
    for _, row in db.iterrows():
        db_symptoms = [sym.lower().strip() for sym in str(row["Symptoms"]).split(",") if sym.strip()]
        for user_sym in input_symptoms:
            for db_sym in db_symptoms:
                if user_sym in db_sym or db_sym in user_sym or similarity(user_sym, db_sym) >= 0.65:
                    matched_conditions.append(row)
                    break
            else:
                continue
            break
    return pd.DataFrame(matched_conditions).drop_duplicates()

def login_page():
    st.title("Lexy- Carekonnect Symptom Checker Login")

    # Create a form for login
    with st.form("login_form"):
        password = st.text_input("Enter Password", type="password")
        submit_button = st.form_submit_button("Login")

    # Check password
    if submit_button:
        if password == "lexmedical":
            st.session_state.logged_in = True
            st.session_state.page = "welcome"
            st.rerun()
        else:
            st.error("Incorrect password. Please try again.")




def welcome_page():
    # ─── 1) Inject custom CSS for styling ───
    st.markdown("""
    <style>
      /* Center and size the logo container */
      .logo-container {
        text-align: center;
        margin-bottom: 1.5rem;
      }
      /* Title styling */
      .welcome-title {
        text-align: center;
        font-size: 2.5rem;
        font-weight: 700;
        margin-bottom: 1rem;
      }
      /* Body text styling */
      .welcome-text {
        max-width: 600px;
        margin: 0 auto 2rem auto;
        font-size: 1.1rem;
        line-height: 1.6;
        color: #444;
      }
      /* Button sizing and coloring */
      .stButton > button {
        width: 220px;
        height: 50px;
        font-size: 1.1rem;
        border-radius: 8px;
        border: none;
        margin-top: 1rem;
      }
      .stButton > button[disabled] {
        background-color: #bbb !important;
        color: #fff !important;
        cursor: not-allowed;
      }
      .stButton > button:not([disabled]) {
        background-color: #e63946 !important;
        color: #fff !important;
      }
      /* Footer styling */
      .footer {
        text-align: center;
        font-size: 0.9rem;
        color: #666;
        margin-top: 3rem;
      }
    </style>
    """, unsafe_allow_html=True)

    # ─── 2) Logo ───
    st.markdown("<div class='logo-container'>", unsafe_allow_html=True)
    st.image(logo, width=120)
    st.markdown("</div>", unsafe_allow_html=True)

    # ─── 3) Welcome text ───
    st.markdown("<div class='welcome-title'>Lexy- AI Based Symptom Checker</div>", unsafe_allow_html=True)
    st.markdown("""
      <div class='welcome-text'>
         <strong>Hi 👋, I’m Lexy — here to help you make sense of your symptoms and feel more in control of your health.</strong><br><br>
        Lexy is an AI Triage tool that helps users better understand their symptoms and suggests next steps—whether that’s self-care, seeing a provider, or seeking urgent help.<br>
        It does not offer medical diagnoses and is not a substitute for care from a qualified health professional.<br><br>
        This tool is not recommended for children under 16, pregnant individuals, or those with multiple health conditions.<br><br>
        <strong>In case of emergency</strong>—such as chest pain, severe bleeding, or difficulty breathing—please call emergency services or go to the nearest hospital.
      </div>
    """, unsafe_allow_html=True)

    # ─── 4) Confirmation checkbox ───
    confirm = st.checkbox("I have read and understood the above")

    # ─── 5) Centered Start button, gated by checkbox ───
    _, center, _ = st.columns([1,2,1])
    with center:
        if st.button("Start Symptom Check", disabled=not confirm):
            st.session_state.page = "user_info"
            st.rerun()

    # ─── 6) Footer ───
    st.markdown("<div class='footer'>Powered by LexMedical Services LTD</div>", unsafe_allow_html=True)

    # ── Hidden Admin Access (testing only) ──
    pwd = st.sidebar.text_input("Dev code", type="password")
    if pwd == "Akinola":  # ← replace with your own secret
        if st.sidebar.button("View Analytics"):
            st.session_state.page = "analytics"
            st.rerun()

def user_info_page():
    st.image(logo, width=80)
    st.subheader("Before we begin, I’d like to know a little about you.")

    with st.form("user_info_form"):
        age = st.number_input("Age", min_value=0, max_value=120)
        # ←— THIS IS THE NEW “Pediatric Mode” NOTE
        if 0 <= age <= 14:
            st.info("👶 Ages 0 – 14 will activate Pediatric mode on the next screen.")

        gender = st.radio("Gender", ["Male", "Female"], horizontal=True)
        conditions = st.text_input(
            "Existing conditions",
            placeholder="Mention any long-term health issues you live with (like asthma or none)"
        )

        submit_col, _ = st.columns([1, 2])
        with submit_col:
            cont = st.form_submit_button("Continue →", type="primary")

    back_col, _ = st.columns([1, 2])
    with back_col:
        back = st.button("← Back")

    if back:
        st.session_state.page = "welcome"
        st.rerun()
    if cont:
        # ── Save demographics ──
        st.session_state.user_data['age']        = age
        st.session_state.user_data['gender']     = gender
        st.session_state.user_data['conditions'] = conditions

        # ── 1) Pediatrics shortcut for ages 0–14 ──
        if 0 <= age <= 14:
            st.session_state.user_data['primary_category'] = "Pediatrics"
            st.session_state.page = "symptom_subcategory"
        else:
            # ── Adult/other flow unchanged ──
            st.session_state.page = "symptom_category"

        st.rerun()

def symptom_category_page():
    # ─── 0) Inject CSS for uniform, wrapped, full-width buttons ───
    st.markdown(
        """<style>
          .stButton > button {
            width: 100% !important;
            white-space: normal !important;
            word-wrap: break-word !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            min-height: 4rem !important;
            padding: 0.75rem 1rem !important;
          }
        </style>""",
        unsafe_allow_html=True
    )

    # ─── 1) Logo & heading ───
    st.image(logo, width=80)
    st.subheader("Let’s start with what’s bothering you today")

    # ─── 2) Gender guard ───
    current_gender = st.session_state.user_data.get('gender')
    if not current_gender:
        st.error("Gender not selected. Please go back.")
        return
    
    # ─── 2b) Age-aware category list (hide Pediatrics for 15+) ───
    current_age = st.session_state.user_data.get('age')

    valid_categories = []
    for cat in db["Primary Category"].unique():

        # Hide Pediatrics for ages 15+
        if (current_age is not None) and (current_age >= 15) and str(cat).strip().lower() == "pediatrics":
            continue
        if is_gender_allowed(cat, current_gender, suppress_error=True):
            valid_categories.append(cat)

   
    # ─── 3) Render your 3-col grid via display_grid ───
    selected = display_grid(valid_categories, cols=3)

    # ─── 4) Handle a valid selection ───
    if selected and is_gender_allowed(selected, current_gender):
        st.session_state.free_input_mode = False
        st.session_state.matched_conditions = pd.DataFrame()
        st.session_state.user_data['primary_category'] = selected
        st.session_state.page = "symptom_subcategory"
        st.rerun()

    # ─── 5) Free-text fallback ───
    if st.button("Can’t find your symptoms? Enter them here"):
        st.session_state.page = "symptom_free_input"
        st.rerun()

    # ─── 6) Back button ───
    if st.button("← Back"):
        st.session_state.page = "user_info"
        st.rerun()

def symptom_free_input_page():
    st.image(logo, width=80)
    st.subheader("What are your symptoms?")
    st.markdown("Enter symptoms separated by commas (e.g., headache, fever, dizziness, leg pain)")

    # — Wrap input & submit in a form so Enter works —
    with st.form("free_input_form"):
        symptom_input = st.text_input("Your symptoms:")
        search = st.form_submit_button("Search Symptoms")

    if search:
        if not symptom_input.strip():
            st.warning("Please enter at least one symptom to search.")
        else:

            # 🔹 Normalize once using the Excel FreeTextMap (and tiny typo fixes)
            symptom_input = normalize_free_text(symptom_input)

            # st.caption(f"normalized: {symptom_input}")

            # 1) Normalize & split on commas
            inputs = [p.strip().lower() for p in symptom_input.split(",") if p.strip()]

            # 2) Tokenize the entire free-text into words ≥3 letters
            user_tokens = re.findall(r"[A-Za-z]{3,}", symptom_input.lower())
            user_stems = [stem(tok) for tok in user_tokens]
            user_stems += [
                                        s[:-1] + ("y" if s.endswith("i") else "i")
                                       for s in user_stems
                                       if s.endswith(("i","y"))
                              ]
            user_stems = list(set(user_stems))

            # --- NEW: separate generics and anchors ---
            user_generics = {t for t in user_tokens if t in GENERIC_TOKENS}
            user_anchors  = [t for t in user_tokens if t not in GENERIC_TOKENS]

            # --- NEW: detect & store generic-only query (no anchors present) ---
            generic_only = bool(user_generics) and not user_anchors
            st.session_state.user_data["generic_only"] = generic_only

            matches   = set()
            threshold = 0.65

            # 3) Scan every DB row
            for idx, row in db.iterrows():
                # consider each symptom entry, splitting on commas or semicolons
                for raw_sym in re.split(r"[,;]", str(row["Symptoms"])):
                    sym_clean = raw_sym.strip().lower()
                    if not sym_clean:
                        continue

                    
                    # --- NEW matching logic with anchor-first gate ---
                    phrase_tokens = re.findall(r"[A-Za-z]{3,}", sym_clean)
                    phrase_stems  = [stem(t) for t in phrase_tokens]
                    phrase_set    = set(phrase_tokens)
                    phrase_stem_set = set(phrase_stems)

                    # 1) Anchor-first gate (unless user gave no anchors)
                    has_anchor_overlap = False
                    if user_anchors:
                        ua_stems = {stem(t) for t in user_anchors}
                        has_anchor_overlap = bool(
                            (set(user_anchors) & phrase_set) or (ua_stems & phrase_stem_set)
                        )
                    else:
                        has_anchor_overlap = True  # allow if no anchors provided

                    if not has_anchor_overlap:
                        continue  # skip this phrase entirely

                    # 2) Generic+specific coherence (if user included generic + anchor)
                    has_any_generic_here = bool(phrase_set & GENERIC_SYNONYMS)

                    # --- NEW: for generic-only queries, require a generic actually present in the phrase ---
                    if generic_only and not has_any_generic_here:
                        continue

                    if user_generics and user_anchors and not has_any_generic_here:
                        continue  # needs a generic synonym in the phrase if user typed generic+anchor

                    # 3) Scoring (precision > recall)
                    score = 0.0

                    # exact phrase hit
                    for raw_s in re.split(r"[,;]", str(row["Symptoms"])):
                        if normalize_free_text(raw_s.strip().lower()) == sym_clean:
                            score += 3.0
                            break

                    # exact token overlap (non-generic)
                    if set(user_anchors) & phrase_set:
                        score += 2.0

                    # stem overlap
                    ua_stems = {stem(t) for t in user_anchors}
                    if ua_stems & phrase_stem_set:
                        score += 1.5

                    # controlled fuzzy (only after anchor gate)
                    def ok_pair(us, ds):
                        if len(us) < 4 or len(ds) < 4:
                            return False
                        return (us in ds) or (ds in us) or (SequenceMatcher(None, us, ds).ratio() >= 0.90)

                    
                    # --- NEW: disable fuzzy for generic-only queries (prevents leakage) ---
                    if (not generic_only) and any(ok_pair(stem(u), stem(p)) for u in user_anchors for p in phrase_tokens):
                        score += 1.0

                    # generic coherence bonus
                    if user_generics and has_any_generic_here:
                        score += 0.5

                    # keep only meaningful matches
                    if score >= 2.0:
                        matches.add(idx)
                        break


                # end raw_sym loop
                # if we matched this row, stop checking it
                if idx in matches:
                    continue

            # 4) Build subset and handle no-matches
            subset = db.loc[sorted(matches)]
            if subset.empty:
                from datetime import datetime
                log_failure({
                    "timestamp": datetime.utcnow().isoformat(),
                    "step":      "free_text_match",
                    "input":     symptom_input,
                    "reason":    "no_symptom_match"
                })
                st.warning(
                    "❗️ No matches found. Check spelling, try again, or speak to a doctor."
                )
                if st.button("Try Again"):
                    st.rerun()
                if st.button("Speak to a Doctor"):
                    st.session_state.page = "fallback_page"
                    st.rerun()
                if st.button("Start Over"):
                    st.session_state.clear()
                    st.session_state.page = "welcome"
                    st.rerun()
                return

            # 5) Save matches & advance
            st.session_state.free_input_mode            = True
            st.session_state.matched_conditions         = subset
            st.session_state.user_data['free_symptoms'] = symptom_input
            st.session_state.page                       = "symptom_primary_category_freeinput"
            st.rerun()

    # — Back button outside the form —
    if st.button("← Back"):
        st.session_state.page = "symptom_category"
        st.rerun()


def symptom_primary_category_freeinput_page():
    # ── Guard: only allow free-text category pick when we actually have matches ──
    if not st.session_state.get("free_input_mode") or st.session_state.matched_conditions.empty:
        # fall back to the normal category picker
        st.session_state.page = "symptom_category"
        st.rerun()

    st.image(logo, width=80)
    st.subheader("What feels closest to how you’re feeling?")

    # now safe: we know matched_conditions exists and has columns
    subset = st.session_state.matched_conditions
    current_gender = st.session_state.user_data.get('gender')
    current_age    = st.session_state.user_data.get('age')

    # --- STRICT dominance filter for generic-only queries ---
    generic_only = bool(st.session_state.user_data.get("generic_only"))
    if generic_only and not subset.empty:
        counts = subset["Primary Category"].value_counts()
        TOP_N = 2  # set to 2 if you want at most two categories
        keep = counts.head(TOP_N).index
        subset = subset[subset["Primary Category"].isin(keep)]


    # Hide Pediatrics for ages 15+
    primaries = [
        cat for cat in sorted(subset["Primary Category"].dropna().unique())
        if (
            # keep Pediatrics only if age < 15
            not ((current_age is not None) and (current_age >= 15) and str(cat).strip().lower() == "pediatrics")
            # still respect gender gating
            and is_gender_allowed(cat, current_gender, suppress_error=True)
        )
    ]

    if not primaries:
        st.warning("We found matches, but none are available for your selected gender/age.")
        if st.button("← Back"):
            st.session_state.page = "symptom_free_input"
            st.rerun()
        return

    choice = display_grid(primaries, cols=2)
    if choice:
        st.session_state.user_data['primary_category'] = choice
        st.session_state.page = "symptom_subcategory"
        st.rerun()

    if st.button("← Back"):
        # Back one step in the free-text flow
        st.session_state.page = "symptom_free_input"
        st.rerun()


def symptom_subcategory_page():
    st.image(logo, width=80)
    st.subheader("Let’s get a bit more specific—what feels closest to what you’re experiencing?")

    # ── Ensure we have a primary category ──
    primary = st.session_state.user_data.get("primary_category")
    if not primary:
        st.error("No category selected. Please start over.")
        if st.button("Start Over"):
            st.session_state.clear()
            st.session_state.page = "welcome"
            st.rerun()
        return

    # ── 3) Pediatric‐mode banner ──
    if primary == "Pediatrics":
        st.info("🧸 Pediatric mode activated—these subcategories are age-appropriate for 0–14 years.")

    # ── Rest of your existing flow ──
    source = (
        st.session_state.matched_conditions
        if st.session_state.get("free_input_mode", False)
        else db
    )
    filtered = source[source["Primary Category"] == primary]
    subcats = sorted(filtered["SubCategory"].dropna().unique())
    choice = display_grid(subcats, cols=2)
    if choice:
        st.session_state.user_data["subcategory"] = choice
        st.session_state.current_condition = filtered[filtered["SubCategory"] == choice].iloc[0]
        st.session_state.page = "symptom_selection"
        st.rerun()

    if st.button("← Back"):
        st.session_state.page = (
            "symptom_primary_category_freeinput"
            if st.session_state.get("free_input_mode", False)
            else "symptom_category"
        )
        st.rerun()

def symptom_selection_page():
    st.image(logo, width=80)
    st.subheader("Tell me about your symptoms")

    primary = st.session_state.user_data.get("primary_category")
    subcat  = st.session_state.user_data.get("subcategory")
    if not primary or not subcat:
        st.error("Category or subcategory missing. Please start over.")
        if st.button("Start Over"):
            st.session_state.clear()
            st.session_state.page = "welcome"
            st.rerun()
        return

    # 1) Decide source: full DB for normal, matched_conditions for free-text
    source = st.session_state.matched_conditions if st.session_state.get("free_input_mode") else db

    # 2) Filter to your chosen subcategory
    subset = source[
        (source["Primary Category"] == primary) &
        (source["SubCategory"]      == subcat)
    ]

    # 3) Aggregate **all** symptoms across those rows
    options = sorted({
        s.strip()
        for row in subset["Symptoms"].dropna()
        for s   in row.split(",")
    })

    # 4) Render them
    selected = st.multiselect("Select all that apply:", options)

    # 5) Navigation
    col1, col2 = st.columns([1,3])
    with col1:
        if st.button("← Back"):
            st.session_state.page = "symptom_subcategory"
            st.rerun()
    with col2:
        if st.button("Continue →"):
            st.session_state.user_data['selected_symptoms'] = selected
            st.session_state.page = "clarifying_questions"
            st.rerun()

def clarifying_questions_page():
    st.image(logo, width=80)
    st.subheader("Just a couple more quick questions to guide you")

    # 1️⃣ Build the subset of rows for this pathway
    primary = st.session_state.user_data.get("primary_category")
    subcat  = st.session_state.user_data.get("subcategory")

    # pick source: full DB if normal, else your matched free-text subset
    source = db if not st.session_state.get("free_input_mode", False) else st.session_state.matched_conditions

    # filter to the chosen primary/subcategory
    subset = source[
        (source["Primary Category"] == primary) &
        (source["SubCategory"]      == subcat)
    ]
    if subset.empty:
        st.error("No conditions found here—please start over.")
        if st.button("Start Over"):
            st.session_state.clear()
            st.session_state.page = "welcome"
            st.rerun()
        return

    # 2️⃣ Stage 1: ask every unique CQ1 in this subset
    if not st.session_state.get("cq1_done"):
        cq1s    = list(subset["Clarifying Questions 1"].dropna().unique())
        answers1 = {}
        with st.form("cq1_form"):
            for i, q in enumerate(cq1s, 1):
                answers1[q] = st.radio(q, ["Yes", "No"], key=f"cq1_{i}")
            if st.form_submit_button("Continue →"):
                st.session_state.user_data["answers1"] = answers1
                st.session_state.cq1_done = True
                st.rerun()

        # Back takes you up one step (category or free-text)
        if st.button("← Back"):
            st.session_state.page = (
                "symptom_primary_category_freeinput"
                if st.session_state.get("free_input_mode", False)
                else "symptom_subcategory"
            )
            st.rerun()
        return

    # 3️⃣ Stage 2: only if any CQ1 was “Yes”
    answers1 = st.session_state.user_data.get("answers1", {})
    if any(v == "Yes" for v in answers1.values()):
        cq2s     = list(subset["Clarifying Questions2"].dropna().unique())
        answers2 = {}
        with st.form("cq2_form"):
            for j, q in enumerate(cq2s, 1):
                answers2[q] = st.radio(q, ["Yes", "No"], key=f"cq2_{j}")
            if st.form_submit_button("Continue →"):
                merged = {**answers1, **answers2}
                st.session_state.user_data["clarifying_answers"] = merged
                st.session_state.page = "risk_flag_selection"
                del st.session_state.cq1_done
                st.rerun()

        # Back goes back into Stage 1
        if st.button("← Back"):
            del st.session_state.cq1_done
            st.rerun()
        return

    # 4️⃣ No “Yes” in CQ1: skip straight to risk flags
    st.session_state.user_data["clarifying_answers"] = answers1
    del st.session_state.cq1_done
    st.session_state.page = "risk_flag_selection"
    st.rerun()

def risk_flag_selection_page():
    st.image(logo, width=80)
    st.subheader("These factors can affect your care. Select any that apply, or “None.”")

    # ── 1) Build the subset of candidate conditions ──
    cat    = st.session_state.user_data.get("primary_category")
    sub    = st.session_state.user_data.get("subcategory")
    source = (
        st.session_state.matched_conditions
        if st.session_state.get("free_input_mode", False)
        else db
    )
    subset = source[
        (source["Primary Category"] == cat) &
        (source["SubCategory"]      == sub)
    ]
    if subset.empty:
        st.error("No conditions found here—please start over.")
        return

    # ── 2) Map CQ2 “Yes” answers back to rows ──
    answers = st.session_state.user_data.get("clarifying_answers", {})
    flagged = []
    for idx, row in subset.iterrows():
        q2 = row["Clarifying Questions2"]
        if pd.notna(q2) and answers.get(q2) == "Yes":
            flagged.append(idx)

    # ── 3) Triaging logic, always run ──
    if len(flagged) == 1:
        chosen_idx = flagged[0]
    elif len(flagged) > 1:
        df_flagged = subset.loc[flagged].copy()
        df_flagged["Acuity Level"] = df_flagged["Acuity Level"].astype(int)
        chosen_idx = df_flagged["Acuity Level"].idxmax()
    else:
        subset["Acuity Level"] = subset["Acuity Level"].astype(int)
        chosen_idx = subset["Acuity Level"].idxmax()

    # ── 4) Save the final condition ──
    st.session_state.current_condition = subset.loc[chosen_idx]

    # ── 5) Render its RiskFlags ──
    cond = st.session_state.current_condition
    raw = str(cond.get("RiskFlags", "") or "")
    flags = [f.strip() for f in raw.split(",") if f.strip()]

    selected = []
    for flag in flags:
        if st.checkbox(flag, key=f"rf_{flag}"):
            selected.append(flag)

    none = st.checkbox("None / Not Applicable", key="rf_none")
    if none and selected:
        st.warning("“None” cannot be combined with other selections; only “None” will be used.")

    # ── 6) Continue → record and go to Results ──
    if st.button("Continue"):
        st.session_state.user_data["confirmed_risks"] = [] if none else selected
        st.session_state.page = "results"
        st.rerun()

    # ← Back → clarifiers
    if st.button("← Back"):
        st.session_state.page = "clarifying_questions"
        st.rerun()



import re

def evaluate_rule(rule_str: str, condition: dict, user_data: dict) -> bool:
    """
    Evaluate a rule like:
      (symptom == itchy eyes AND cq1 == yes)
      OR risk_flag == Chronic (>6 weeks)
    by checking:
      - whether 'itchy eyes' is listed in condition['Symptoms']
      - whether user_data['clarifying_answers']['cq1'] == 'Yes'
      - whether 'Chronic (>6 weeks)' is listed in condition['RiskFlags']
    """
    # Pre-split the human lists
    syms = [s.strip().lower() for s in condition.get("Symptoms", "").split(",")]
    rfs  = [r.strip().lower() for r in condition.get("RiskFlags", "").split(",")]

    # Helper to evaluate a single atom
    def eval_atom(atom: str) -> bool:
        atom = atom.strip()

        # symptom == X
        m = re.match(r"^symptom\s*==\s*(.+)$", atom, re.IGNORECASE)
        if m:
            value = m.group(1).strip().lower()
            return value in syms

        # risk_flag == Y
        m = re.match(r"^risk_flag\s*==\s*(.+)$", atom, re.IGNORECASE)
        if m:
            value = m.group(1).strip().lower()
            return value in rfs

        # cqN == yes → just check answer for question N
        m = re.match(r"^cq(\d+)\s*==\s*yes$", atom, re.IGNORECASE)
        if m:
            idx = int(m.group(1))
            return user_data.get("clarifying_answers", {})\
                            .get(f"cq{idx}", "").strip().lower() == "yes"

        # Unknown atom → False
        return False

    # Tokenize rule_str into parentheses, AND, OR, or atoms
    parts = re.split(r"(\bAND\b|\bOR\b|\(|\))", rule_str, flags=re.IGNORECASE)
    expr = ""
    for part in parts:
        part_strip = part.strip()
        if re.fullmatch(r"AND", part_strip, re.IGNORECASE):
            expr += " and "
        elif re.fullmatch(r"OR", part_strip, re.IGNORECASE):
            expr += " or "
        elif part_strip in ("(", ")"):
            expr += part_strip
        elif part_strip:
            # It's an atom
            expr += str(eval_atom(part_strip))

    # Finally, eval the boolean Python expression
    try:
        return bool(eval(expr))
    except Exception:
        return False


def make_recommendation(condition: dict, user_flags: dict, risk_flags: list) -> str:
    # Determine escalation
    acuity = condition.get("Acuity Level", 0)
    is_esc = bool(risk_flags) or (acuity == 3)

    # Confidence guard
    conf = condition.get("Labeling Confidence", "Low")
    if conf == "Low":
        return ""

    # Rule match guard (allow escalation)
    rule_ok = evaluate_rule(
                    condition["Labeling Rule"],
                    condition,
                    st.session_state.user_data
    )

    # Certainty phrase
    certainty = "very likely" if conf == "High" else "symptoms suggest"

    # Pick templates
    if is_esc:
        base_tmpl = condition.get("Escalated Narrative Template (Risk Flags Present)", "")
        rec_text = condition.get("Escalated Recommendation", "")
    else:
        base_tmpl = condition.get("Default Narrative Template", "")
        rec_text = condition.get("Default Recommendation", "")

    # Render base with placeholders
    base = base_tmpl.format(
        certainty=certainty,
        risk_flags=", ".join(risk_flags),
        default_rec=condition.get("Default Recommendation", ""),
        escalated_rec=condition.get("Escalated Recommendation", "")
    )

    # Build recommendation without duplication
    if ('{default_rec}' in base_tmpl) or ('{escalated_rec}' in base_tmpl):
        recommendation = base
    else:
        recommendation = f"{base} {rec_text}".strip()

     #Append emergency note marker
    note = condition.get("Emergency Narrative (If Applicable)", "").strip()
    if note:
        recommendation += f"\n\n🚨 Important: {note}"

    return recommendation


def results_page():
    # Header and Title
    st.image(logo, width=80)
    st.header("Based on your answers, your likely condition is:")

    # Fetch the chosen condition
    condition = st.session_state.current_condition
    if condition is None:
        st.error("No condition selected. Please start over.")
        if st.button("🔄 Start New Check"):
            st.session_state.clear()
            st.session_state.page = "welcome"
            st.rerun()
        return

    # Show the condition's name
    condition_title = condition.get("Condition", "")
    st.subheader(condition_title)

    # Determine baseline acuity (for card color)
    if st.session_state.get("free_input_mode"):
        baseline_rank = int(st.session_state.matched_conditions.get("Acuity Level", 0).max())
    else:
        baseline_rank = int(condition.get("Acuity Level", 0) or 0)

    # Gather & sanitize risk flags (avoid accidental truthy [""])
    raw_flags  = st.session_state.user_data.get("confirmed_risks", [])
    risk_flags = [rf.strip() for rf in raw_flags if isinstance(rf, str) and rf.strip()]

    # ——— Assemble user_flags with normalized keys ———
    user_data  = st.session_state.user_data
    user_flags = {}

    # 1) Symptoms from selected_symptom
    for sym in user_data.get("selected_symptoms", []):
        key = sym.strip().lower().replace(" ", "_")
        user_flags[key] = True

    # 2) Clarifiers from clarifying_answers
    for question, ans in user_data.get("clarifying_answers", {}).items():
        if ans == "Yes":
            key = question.strip().lower().replace(" ", "_")
            user_flags[key] = True

    # 3) Risk flags
    for rf in risk_flags:
        key = rf.strip().lower().replace(" ", "_")
        user_flags[key] = True

    # Generate recommendation (string may include an appended emergency line in older builds)
    recommendation = make_recommendation(condition, user_flags, risk_flags)

    # Display recommendation or fallback with styled blocks
    if recommendation:
        # Your escalation rule for card color:
        is_esc = (baseline_rank == 3) or bool(risk_flags)
        block_class = "report-block" if is_esc else "report-block report-block--ok"

        # If the recommendation string contains an appended emergency line,
        # strip it from the main text to avoid duplication (we render emergency separately).
        parts = recommendation.split('\n\n🚨 Important: ')
        main_text = parts[0].strip()

        # MAIN CARD (mobile-friendly class)
        safe_text = main_text.replace('\n', '<br>')
        html = (
            f"<div class='{block_class}'>"
            f"{safe_text}"
            "</div>"
        )


        # Optional referral line below the card
        ref_text = (condition.get("Referral", "") or "").strip()
        if ref_text:
            html += f"<p><strong>{ref_text}</strong></p>"

        st.markdown(html, unsafe_allow_html=True)

        # EMERGENCY NOTE — render once, as a separate block
        emergency = (condition.get("Emergency Narrative (If Applicable)", "") or "").strip()
        if emergency:
            st.markdown(
                f"<div class='emergency-block'>🚨 Important: {emergency}</div>",
                unsafe_allow_html=True
            )

    else:
        # Fallback amber (mobile-friendly)
        html = (
            "<div class='report-block report-block--warn'>"
            "I’m not able to match a condition confidently. Please consider consulting a "
            "healthcare professional for a definitive evaluation."
            "</div>"
        )
        st.markdown(html, unsafe_allow_html=True)

    # Optional: Schedule Appointment button
    if condition.get("Referral") and st.button("📅 Schedule an Appointment"):
        st.info("Appointment scheduling will be available soon.")

    # Download report & New Check buttons (single set; CSS centers on mobile only)
    col1, col2 = st.columns([1, 1])

    with col1:
        report_text = generate_report()
        st.download_button(
            label="📄 Download Full Report",
            data=report_text,
            file_name=f"{condition_title}_report.txt",
            key="dl_report"
        )

    with col2:
        if st.button("🔄 Start New Check", key="newcheck"):
            st.session_state.clear()
            st.session_state.page = "welcome"
            st.rerun()

   # ⬇️ CSS comes immediately after these buttons
    st.markdown("""
    <style>
    @media (max-width: 640px) {
      /* Center the download button itself */
      div[data-testid="stDownloadButton"] > button {
        display: block !important;
        margin-left: auto !important;
        margin-right: auto !important;
      }
    }
    </style>
    """, unsafe_allow_html=True)



def fallback_page():
    st.image(logo, width=80)
    st.warning("I couldn’t find a clear match for your symptoms, which could mean they’re mild or need professional evaluation.")
    st.markdown("**Would you like to speak with a Doctor about this?**")
    col1, col2, col3 = st.columns([1,1,1])
    with col1:
        if st.button("📅 Schedule an Appointment"):
            st.info("Appointment scheduling flow will be implemented here.")
    with col2:
        if st.button("🔄 Start Over"):
            st.session_state.clear()
            st.session_state.page = "welcome"
            st.rerun()
    with col3:
        if st.button("← Back"):
            st.session_state.page = "clarifying_questions"
            st.rerun()

PAGES = {
    "welcome": welcome_page,
    "user_info": user_info_page,
    "symptom_category": symptom_category_page,
    "symptom_free_input": symptom_free_input_page,
    "symptom_primary_category_freeinput": symptom_primary_category_freeinput_page,
    "symptom_subcategory": symptom_subcategory_page,
    "symptom_selection": symptom_selection_page,
    "clarifying_questions": clarifying_questions_page,
    "risk_flag_selection": risk_flag_selection_page,
    "results": results_page,
    "fallback_page": fallback_page,
    "analytics": analytics_page,
}
# ---- Auth gate: show login until authenticated ----
if not st.session_state.get("logged_in", False):
    login_page()
    st.stop()

PAGES[st.session_state.page]()